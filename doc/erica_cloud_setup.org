#+SETUPFILE: theme-readtheorg.setup
#+TITLE: ERICA Cloud Setup
#+AUTHOR: Arthur Andersen

This document explains how to setup ERICA on a newly created cloud
instance or server in a data center.

* Install administration tools

#+BEGIN_SRC shell
apt-get update
apt-get install screen mosh htop
#+END_SRC

* Set hostname

#+BEGIN_SRC shell
NEW_HOSTNAME=erica-cloud-abx
sed -i -e "s/$(hostname)/$NEW_HOSTNAME/g" /etc/hosts
hostnamectl set-hostname $NEW_HOSTNAME
/etc/init.d/hostname.sh start
#+END_SRC

* Configure firewall



* Install Docker Environment
** Install Docker
#+BEGIN_SRC shell
  # Update the apt package index
  apt-get update
  # Install packages to allow apt to use a repository over HTTPS
  apt-get install -y apt-transport-https ca-certificates curl software-properties-common
  # Add Dockerâ€™s official GPG key:
  curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -
  #
  apt-key fingerprint 0EBFCD88
  # Set up stable repository
  add-apt-repository "deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable"
  # Update the apt package index
  apt-get update
  apt-get install -y docker-ce=17.09.0~ce-0~ubuntu
#+END_SRC

** Install Docker Compose

#+BEGIN_SRC shell
  curl -L https://github.com/docker/compose/releases/download/1.16.1/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose
#+END_SRC

** Configure velaluqa docker registry

Use the ~pharmtrace_deploy~ user to login at the velaluqa docker
registry.

#+BEGIN_SRC
docker login registry.velalu.qa:443
#+END_SRC

* Start all necessary containers
** Create directory structure

#+BEGIN_SRC shell
  mkdir -p /srv/volumes/{proxy/templates,erica/config,erica/log,erica/tmp}
#+END_SRC

** Create ~docker-compose.yml~ file

#+BEGIN_SRC yaml
  postgres:
    container_name: erica_postgres_production
    image: postgres:9.6
    restart: always
    volumes:
      - ./volumes/postgresql/data:/var/lib/postgresql/data
    environment:
      POSTGRES_PASSWORD: 'pharmtrace#2018#erica'
  redis:
    container_name: erica_redis_production
    image: redis:4.0
    restart: always
  app:
    container_name: erica_app_production
    image: &app_image registry.velalu.qa:443/pharmtrace/ericastore:develop
    command: bundle exec unicorn -p 3000
    restart: always
    environment: &environment
      RAILS_ENV: production
      ERICA_HOST: &erica_host 'sirtex.pharmtrace.eu'
      # Configuration of outgoing mails:
      SMTP_PORT: 587
      SMTP_SERVER: 'mail.hilbert-space.org'
      SMTP_USERNAME: pharmtrace@velalu.qa
      SMTP_PASSWORD: 2zM6rca772
      SMTP_SENDER: pharmtrace@velalu.qa
      SMTP_STARTTLS_AUTO: 'true'
      # Proxy and SSL configuration:
      VIRTUAL_HOST: *erica_host
      LETSENCRYPT_HOST: *erica_host
      LETSENCRYPT_EMAIL: aandersen@velalu.qa
    ports:
      - 3000
    volumes: &volumes
      - ./volumes/erica/config/database.yml:/app/config/database.yml
      - /data:/app/data
      - ./volumes/erica/log:/app/log
      - ./volumes/erica/tmp:/app/tmp
    links: &links
      - postgres
      - redis
      - worker
  worker:
    container_name: erica_sidekiq_production
    image: *app_image
    command: bundle exec sidekiq
    environment: *environment
    volumes: *volumes
    links:
      - postgres
      - redis
    restart: always
  nginx:
    image: nginx
    container_name: nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - "/etc/nginx/conf.d"
      - "/etc/nginx/vhost.d"
      - "/usr/share/nginx/html"
      - "./volumes/proxy/certs:/etc/nginx/certs:ro"
  nginx-gen:
    image: jwilder/docker-gen
    container_name: nginx-gen
    volumes:
      - "/var/run/docker.sock:/tmp/docker.sock:ro"
      - "./volumes/proxy/templates/nginx.tmpl:/etc/docker-gen/templates/nginx.tmpl:ro"
    volumes_from:
      - nginx
    entrypoint: /usr/local/bin/docker-gen -notify-sighup nginx -watch -only-exposed -wait 5s:30s /etc/docker-gen/templates/nginx.tmpl /etc/nginx/conf.d/default.conf
  letsencrypt-nginx-proxy-companion:
    image: jrcs/letsencrypt-nginx-proxy-companion
    container_name: letsencrypt-nginx-proxy-companion
    volumes_from:
      - nginx
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock:ro"
      - "./volumes/proxy/certs:/etc/nginx/certs:rw"
    environment:
      - NGINX_DOCKER_GEN_CONTAINER=nginx-gen
#+END_SRC

** Create Nginx Template

Put this file to ~/srv//volumes/proxy/templates/nginx.tmpl/~

#+BEGIN_SRC text
  {{ define "upstream" }}
      {{ if .Address }}
          {{/* If we got the containers from swarm and this container's port is published to host, use host IP:PORT */}}
          {{ if and .Container.Node.ID .Address.HostPort }}
              # {{ .Container.Node.Name }}/{{ .Container.Name }}
              server {{ .Container.Node.Address.IP }}:{{ .Address.HostPort }};
          {{/* If there is no swarm node or the port is not published on host, use container's IP:PORT */}}
          {{ else }}
              # {{ .Container.Name }}
              server {{ .Address.IP }}:{{ .Address.Port }};
          {{ end }}
      {{ else }}
          # {{ .Container.Name }}
          server {{ .Container.IP }} down;
      {{ end }}
  {{ end }}

  # If we receive X-Forwarded-Proto, pass it through; otherwise, pass along the
  # scheme used to connect to this server
  map $http_x_forwarded_proto $proxy_x_forwarded_proto {
    default $http_x_forwarded_proto;
    ''      $scheme;
  }

  # If we receive Upgrade, set Connection to "upgrade"; otherwise, delete any
  # Connection header that may have been passed to this server
  map $http_upgrade $proxy_connection {
    default upgrade;
    '' close;
  }

  gzip_types text/plain text/css application/javascript application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript;

  log_format vhost '$host $remote_addr - $remote_user [$time_local] '
                   '"$request" $status $body_bytes_sent '
                   '"$http_referer" "$http_user_agent"';

  access_log off;

  {{ if (exists "/etc/nginx/proxy.conf") }}
  include /etc/nginx/proxy.conf;
  {{ else }}
  # HTTP 1.1 support
  proxy_http_version 1.1;
  proxy_buffering off;
  proxy_set_header Host $http_host;
  proxy_set_header Upgrade $http_upgrade;
  proxy_set_header Connection $proxy_connection;
  proxy_set_header X-Real-IP $remote_addr;
  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
  proxy_set_header X-Forwarded-Proto $proxy_x_forwarded_proto;
  {{ end }}

  server {
      server_name _; # This is just an invalid value which will never trigger on a real hostname.
      listen 80;
      access_log /var/log/nginx/access.log vhost;
      return 503;
  }

  {{ if (and (exists "/etc/nginx/certs/default.crt") (exists "/etc/nginx/certs/default.key")) }}
  server {
      server_name _; # This is just an invalid value which will never trigger on a real hostname.
      listen 443 ssl http2;
      access_log /var/log/nginx/access.log vhost;
      return 503;

      ssl_certificate /etc/nginx/certs/default.crt;
      ssl_certificate_key /etc/nginx/certs/default.key;
  }
  {{ end }}

  {{ range $host, $containers := groupByMulti $ "Env.VIRTUAL_HOST" "," }}

  upstream {{ $host }} {
  {{ range $container := $containers }}
      {{ $addrLen := len $container.Addresses }}
      {{/* If only 1 port exposed, use that */}}
      {{ if eq $addrLen 1 }}
          {{ $address := index $container.Addresses 0 }}
          {{ template "upstream" (dict "Container" $container "Address" $address) }}
      {{/* If more than one port exposed, use the one matching VIRTUAL_PORT env var, falling back to standard web port 80 */}}
      {{ else }}
          {{ $port := coalesce $container.Env.VIRTUAL_PORT "80" }}
          {{ $address := where $container.Addresses "Port" $port | first }}
          {{ template "upstream" (dict "Container" $container "Address" $address) }}
      {{ end }}
  {{ end }}
  }

  {{ $default_host := or ($.Env.DEFAULT_HOST) "" }}
  {{ $default_server := index (dict $host "" $default_host "default_server") $host }}

  {{/* Get the VIRTUAL_PROTO defined by containers w/ the same vhost, falling back to "http" */}}
  {{ $proto := or (first (groupByKeys $containers "Env.VIRTUAL_PROTO")) "http" }}

  {{/* Get the first cert name defined by containers w/ the same vhost */}}
  {{ $certName := (first (groupByKeys $containers "Env.CERT_NAME")) }}

  {{/* Get the best matching cert  by name for the vhost. */}}
  {{ $vhostCert := (closest (dir "/etc/nginx/certs") (printf "%s.crt" $host))}}

  {{/* vhostCert is actually a filename so remove any suffixes since they are added later */}}
  {{ $vhostCert := replace $vhostCert ".crt" "" -1 }}
  {{ $vhostCert := replace $vhostCert ".key" "" -1 }}

  {{/* Use the cert specifid on the container or fallback to the best vhost match */}}
  {{ $cert := (coalesce $certName $vhostCert) }}

  {{ if (and (ne $cert "") (exists (printf "/etc/nginx/certs/%s.crt" $cert)) (exists (printf "/etc/nginx/certs/%s.key" $cert))) }}

  server {
      server_name {{ $host }};
      listen 80 {{ $default_server }};
      access_log /var/log/nginx/access.log vhost;
      return 301 https://$host$request_uri;
  }

  server {
      server_name {{ $host }};
      listen 443 ssl http2 {{ $default_server }};
      access_log /var/log/nginx/access.log vhost;

      ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
      ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:CAMELLIA:DES-CBC3-SHA:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!aECDH:!EDH-DSS-DES-CBC3-SHA:!EDH-RSA-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA;

      ssl_prefer_server_ciphers on;
      ssl_session_timeout 5m;
      ssl_session_cache shared:SSL:50m;

      ssl_certificate /etc/nginx/certs/{{ (printf "%s.crt" $cert) }};
      ssl_certificate_key /etc/nginx/certs/{{ (printf "%s.key" $cert) }};

      {{ if (exists (printf "/etc/nginx/certs/%s.dhparam.pem" $cert)) }}
      ssl_dhparam {{ printf "/etc/nginx/certs/%s.dhparam.pem" $cert }};
      {{ end }}

      add_header Strict-Transport-Security "max-age=31536000";

      {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
      include {{ printf "/etc/nginx/vhost.d/%s" $host }};
      {{ else if (exists "/etc/nginx/vhost.d/default") }}
      include /etc/nginx/vhost.d/default;
      {{ end }}

      location / {
          proxy_pass {{ trim $proto }}://{{ trim $host }};
          {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
          auth_basic  "Restricted {{ $host }}";
          auth_basic_user_file    {{ (printf "/etc/nginx/htpasswd/%s" $host) }};
          {{ end }}
                  {{ if (exists (printf "/etc/nginx/vhost.d/%s_location" $host)) }}
                  include {{ printf "/etc/nginx/vhost.d/%s_location" $host}};
                  {{ else if (exists "/etc/nginx/vhost.d/default_location") }}
                  include /etc/nginx/vhost.d/default_location;
                  {{ end }}
      }
  }
  {{ else }}

  server {
      server_name {{ $host }};
      listen 80 {{ $default_server }};
      access_log /var/log/nginx/access.log vhost;

      {{ if (exists (printf "/etc/nginx/vhost.d/%s" $host)) }}
      include {{ printf "/etc/nginx/vhost.d/%s" $host }};
      {{ else if (exists "/etc/nginx/vhost.d/default") }}
      include /etc/nginx/vhost.d/default;
      {{ end }}

      location / {
          proxy_pass {{ trim $proto }}://{{ trim $host }};
          {{ if (exists (printf "/etc/nginx/htpasswd/%s" $host)) }}
          auth_basic  "Restricted {{ $host }}";
          auth_basic_user_file    {{ (printf "/etc/nginx/htpasswd/%s" $host) }};
          {{ end }}
                  {{ if (exists (printf "/etc/nginx/vhost.d/%s_location" $host)) }}
                  include {{ printf "/etc/nginx/vhost.d/%s_location" $host}};
                  {{ else if (exists "/etc/nginx/vhost.d/default_location") }}
                  include /etc/nginx/vhost.d/default_location;
                  {{ end }}
      }
  }

  {{ if (and (exists "/etc/nginx/certs/default.crt") (exists "/etc/nginx/certs/default.key")) }}
  server {
      server_name {{ $host }};
      listen 443 ssl http2 {{ $default_server }};
      access_log /var/log/nginx/access.log vhost;
      return 503;

      ssl_certificate /etc/nginx/certs/default.crt;
      ssl_certificate_key /etc/nginx/certs/default.key;
  }
  {{ end }}

  {{ end }}
  {{ end }}
#+END_SRC

** Setup Database

#+BEGIN_SRC shell
cd /srv
docker-compose up -d postgres
docker exec -it erica_postgres_production su postgres -c "psql -c \"CREATE USER erica WITH PASSWORD '<erica password>'\""
docker exec -it erica_postgres_production su postgres -c "psql -c \"CREATE DATABASE erica_production\""
docker exec -it erica_postgres_production su postgres -c "psql -c \"GRANT ALL PRIVILEGES ON DATABASE erica_production to erica;\""
#+END_SRC

** Configure ERICA

*** Create database configuration file

#+BEGIN_SRC yaml
  production: &default
    adapter: postgresql
    encoding: unicode
    pool: 30
    timeout: 5000
    host: postgres
    username: erica
    password: '<erica password>'
    database: erica_production
#+END_SRC

*** Initialize Database Schema

#+BEGIN_SRC shell
cd /srv
docker-compose run --rm app rake db:migrate
#+END_SRC

*** Bootstrap Roles and Root User

#+BEGIN_SRC shell
cd /srv
docker-compose run --rm app rake erica:seed:roles
docker-compose run --rm app rake erica:seed:root_user[root]
#+END_SRC

** Start services

#+BEGIN_SRC
docker-compose up -d
#+END_SRC
